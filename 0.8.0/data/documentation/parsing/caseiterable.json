{"metadata":{"role":"article","modules":[{"name":"Parsing"}],"roleHeading":"Article","title":"CaseIterable"},"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"]]},"sections":[],"primaryContentSections":[{"content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"inlineContent":[{"text":"Given a type that conforms to ","type":"text"},{"code":"CaseIterable","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"RawRepresentable","type":"codeVoice"},{"text":" with a ","type":"text"},{"code":"RawValue","type":"codeVoice"},{"text":" of ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" ","type":"text"},{"text":"or ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":", we can incrementally parse a value of it.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Notably, raw enumerations that conform to ","type":"text"},{"type":"codeVoice","code":"CaseIterable"},{"text":" meet this criteria, so cases of the","type":"text"},{"text":" ","type":"text"},{"text":"following type can be parsed with no extra work:","type":"text"}],"type":"paragraph"},{"code":["enum Role: String, CaseIterable {","  case admin","  case guest","  case member","}","","try Parse {","  Int.parser()","  \",\"","  Role.parser()","}",".parse(\"123,member\") \/\/ (123, .member)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This also works with raw enumerations that are backed by integers:","type":"text"}],"type":"paragraph"},{"code":["enum Role: Int, CaseIterable {","  case admin = 1","  case guest = 2","  case member = 3","}","","try Parse {","  Int.parser()","  \",\"","  Role.parser()","}",".parse(\"123,1\") \/\/ (123, .admin)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"parser()","type":"codeVoice"},{"text":" method on ","type":"text"},{"code":"CaseIterable","type":"codeVoice"},{"text":" is overloaded to work on a variety of string representations","type":"text"},{"text":" ","type":"text"},{"text":"in order to be as efficient as possible, including ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":", ","type":"text"},{"code":"UTF8View","type":"codeVoice"},{"text":", and more general","type":"text"},{"text":" ","type":"text"},{"text":"collections of UTF-8 code units (see ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","isActive":true,"type":"reference"},{"text":" for more info).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Typically Swift can choose the correct overload by using type inference based on what other parsers","type":"text"},{"text":" ","type":"text"},{"text":"you are combining ","type":"text"},{"type":"codeVoice","code":"parser()"},{"text":" with. For example, if you use ","type":"text"},{"type":"codeVoice","code":"Role.parser()"},{"text":" with a","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Substring"},{"text":" parser, like the literal ‚Äú,‚Äù parser in the above examples, Swift","type":"text"},{"text":" ","type":"text"},{"text":"will choose the overload that works on substrings.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"On the other hand, if ","type":"text"},{"type":"codeVoice","code":"Role.parser()"},{"text":" is used in a context where the input type cannot be inferred,","type":"text"},{"text":" ","type":"text"},{"text":"then you will get an compiler error:","type":"text"}],"type":"paragraph"},{"code":["let parser = Parse {","  Int.parser()","  Role.parser() \/\/ üõë Ambiguous use of 'parser(of:)'","}","","try parser.parse(\"123member\")"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"To fix this you can force one of the parsers to be the ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":" parser, and then the","type":"text"},{"text":" ","type":"text"},{"text":"other will figure it out via type inference:","type":"text"}],"type":"paragraph"},{"code":["let parser = Parse {","  Int.parser(of: Substring.self)","  Role.parser()","}","","try parser.parse(\"123member\") \/\/ (123, .member)"],"type":"codeListing","syntax":"swift"}],"kind":"content"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/CaseIterable"},"abstract":[{"text":"A parser that consumes a case-iterable, raw representable value from the beginning of a string.","type":"text"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/parsing\/caseiterable"]}],"kind":"article","schemaVersion":{"major":0,"patch":0,"minor":2},"references":{"doc://co.pointfree.Parsing/documentation/Parsing":{"role":"collection","title":"Parsing","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"A library for turning nebulous data into well-structured data, with a focus on composition,"},{"type":"text","text":" "},{"type":"text","text":"performance, generality, and ergonomics."}],"url":"\/documentation\/parsing","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"},"doc://co.pointfree.Parsing/documentation/Parsing/StringAbstractions":{"url":"\/documentation\/parsing\/stringabstractions","kind":"article","type":"topic","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","abstract":[{"type":"text","text":"Learn how to write parsers on different levels of string abstractions, giving you the ability to"},{"type":"text","text":" "},{"type":"text","text":"trade performance for correctness where needed."}],"title":"String Abstractions","role":"article"}}}