{"primaryContentSections":[{"content":[{"anchor":"Levels-of-abstraction","level":2,"type":"heading","text":"Levels of abstraction"},{"inlineContent":[{"text":"The parsers in the library do not work on ","type":"text"},{"code":"String","type":"codeVoice"},{"text":"s directly, and instead operate on ","type":"text"},{"inlineContent":[{"type":"text","text":"views"}],"type":"emphasis"},{"text":" into a","type":"text"},{"text":" ","type":"text"},{"text":"string, such as ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":", ","type":"text"},{"code":"UnicodeScalarView","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"UTF8View","type":"codeVoice"},{"text":". Each of these types represents a","type":"text"},{"text":" ","type":"text"},{"text":"particular kind of ‚Äúview‚Äù into some subset of a string, which means they are cheap to copy around,","type":"text"},{"text":" ","type":"text"},{"text":"and it makes consuming elements from the beginning and end of the string very efficient since only","type":"text"},{"text":" ","type":"text"},{"text":"their start and end index need to be mutated to point to different parts of the string.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, there are tradeoffs to using each type:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"Substring","type":"codeVoice"},{"type":"text","text":", like "},{"code":"String","type":"codeVoice"},{"type":"text","text":", is a collection of "},{"code":"Character","type":"codeVoice"},{"type":"text","text":"s, which are extended grapheme"},{"type":"text","text":" "},{"type":"text","text":"clusters that most closely represents a single visual character one can see on the screen. This"},{"type":"text","text":" "},{"type":"text","text":"type is easy to use and hides a lot of the complexities of UTF8 from you (such as multiple byte"},{"type":"text","text":" "},{"type":"text","text":"sequences that represent the same visual character), and as such it is less efficient to use."},{"type":"text","text":" "},{"type":"text","text":"Its elements are variable width, which means scanning its elements is an O(n) operation."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"UnicodeScalarView","type":"codeVoice"},{"text":" is a collection of unicode scalars represented by the ","type":"text"},{"code":"Unicode.Scalar","type":"codeVoice"},{"text":" type.","type":"text"},{"text":" ","type":"text"},{"text":"Unicode scalars are 21-bit, and so not variable width like ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":", which makes scanning","type":"text"},{"text":" ","type":"text"},{"code":"UnicodeScalarView","type":"codeVoice"},{"text":"s more efficient, but at the cost of some additional complexity in the API.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For example, complex elements that can be represented by a single ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":", such as ‚Äúüá∫üá∏‚Äù,","type":"text"},{"text":" ","type":"text"},{"text":"are represented by multiple ","type":"text"},{"type":"codeVoice","code":"Unicode.Scalar"},{"text":" elements, ‚Äúüá∫‚Äù and ‚Äúüá∏‚Äù. When put together they","type":"text"},{"text":" ","type":"text"},{"text":"form the single extended grapheme cluster of the flag character.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further, some "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"s have multiple representations as collections of unicode scalars. For"},{"type":"text","text":" "},{"type":"text","text":"example, an ‚Äúe‚Äù with an accute accent only has one visual representation, yet there are two"},{"type":"text","text":" "},{"type":"text","text":"different sequences of unicode scalars that can represent that character:"}]},{"syntax":"swift","type":"codeListing","code":["Array(\"√©\".unicodeScalars) \/\/ [233]","Array(\"eÃÅ\".unicodeScalars) \/\/ [101, 769]"]},{"type":"paragraph","inlineContent":[{"text":"You can‚Äôt tell from looking at the character, but the first ‚Äú√©‚Äù is a single unicode scalar","type":"text"},{"text":" ","type":"text"},{"text":"called a ‚ÄúLATIN SMALL LETTER E WITH ACUTE‚Äù and the second ‚ÄúeÃÅ‚Äù is two scalars, one just a plain","type":"text"},{"text":" ","type":"text"},{"text":"‚Äúe‚Äù and the second a ‚ÄúCOMBINING ACUTE ACCENT‚Äù. Importantly, these two accented e‚Äôs are equal as","type":"text"},{"text":" ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":"s but unequal as ","type":"text"},{"code":"UnicodeScalarView","type":"codeVoice"},{"text":"s:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let e1 = \"\\u{00E9}\"","let e2 = \"e\\u{0301}\"","e1 == e2 \/\/ true","e1.unicodeScalars.elementsEqual(e2.unicodeScalars) \/\/ false"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, when parsing on the level of "},{"code":"UnicodeScalarView","type":"codeVoice"},{"type":"text","text":" you have to be aware of these subtleties in"},{"type":"text","text":" "},{"type":"text","text":"order to form a correct parser."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"UTF8View","type":"codeVoice"},{"type":"text","text":" is a collection of "},{"code":"Unicode.UTF8.CodeUnit","type":"codeVoice"},{"type":"text","text":"s, which is just a typealias for "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"i.e.","type":"text"}]},{"type":"text","text":", a single byte. This is an even lower-level representation of strings than"},{"type":"text","text":" "},{"code":"UnicodeScalarView","type":"codeVoice"},{"type":"text","text":", and scanning these collections is quite efficient, but at the cost of even"},{"type":"text","text":" "},{"type":"text","text":"more complexity."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the non-ASCII characters described above have an even more complex representation"},{"type":"text","text":" "},{"type":"text","text":"has UTF8 bytes:"}]},{"type":"codeListing","syntax":"swift","code":["Array(\"√©\".utf8) \/\/ [195, 169]","Array(\"eÃÅ\".utf8) \/\/ [101, 204, 129]","Array(\"üá∫üá∏\".utf8) \/\/ [240, 159, 135, 186, 240, 159, 135, 184]"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There‚Äôs even "},{"code":"ArraySlice<UInt8>","type":"codeVoice"},{"type":"text","text":", which is just a raw collection of bytes. This can be even more"},{"type":"text","text":" "},{"type":"text","text":"efficient to parse than "},{"code":"UTF8View","type":"codeVoice"},{"type":"text","text":" because it does not require representing a valid UTF-8"},{"type":"text","text":" "},{"type":"text","text":"string, but then you have no guarantees that you can losslessly convert it back into a "},{"code":"String","type":"codeVoice"},{"type":"text","text":"."}]}]}],"type":"unorderedList"},{"anchor":"Mixing-and-matching-abstraction-levels","level":2,"type":"heading","text":"Mixing and matching abstraction levels"},{"inlineContent":[{"text":"It is possible to plug together parsers that work on different abstraction levels so that you can","type":"text"},{"text":" ","type":"text"},{"text":"decide where you want to trade correctness for performance and vice-versa.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For example, suppose you have an enum representing a few cities that you want to parse a string","type":"text"},{"text":" ","type":"text"},{"text":"into:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["enum City {","  case losAngeles","  case newYork","  case sanJose","}","","let city = OneOf {","  \"Los Angeles\".map { City.losAngeles }","  \"New York\".map { City.newYork }","  \"San Jos√©\".map { City.sanJose }","}"]},{"inlineContent":[{"text":"For the most part this parser could work on the level of UTF-8 because it is mostly dealing with","type":"text"},{"text":" ","type":"text"},{"text":"plain ASCII characters for which there are not multiple ways of representing the same visual","type":"text"},{"text":" ","type":"text"},{"text":"character. The only exception is ‚ÄúSan Jos√©‚Äù, which has an accented ‚Äúe‚Äù that can be represented","type":"text"},{"text":" ","type":"text"},{"text":"by two different sequences of bytes.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":" abstraction is hiding those details from us because this parser will happily parse","type":"text"},{"text":" ","type":"text"},{"text":"both representations of ‚ÄúSan Jos√©‚Äù from a string:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["city.parse(\"San Jos\\u{00E9}\")  \/\/ ‚úÖ","city.parse(\"San Jose\\u{0301}\") \/\/ ‚úÖ"]},{"inlineContent":[{"text":"But, if we naively convert this parser to work on the level of ","type":"text"},{"code":"UTF8View","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let city = OneOf {","  \"Los Angeles\".utf8.map { City.losAngeles }","  \"New York\".utf8.map { City.newYork }","  \"San Jos√©\".utf8.map { City.sanJose }","}"]},{"inlineContent":[{"type":"text","text":"We have accidentally introduced a bug into the parser in which it recognizes one version of"},{"type":"text","text":" "},{"type":"text","text":"‚ÄúSan Jos√©‚Äù, but not the other:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["city.parse(\"San Jos\\u{00E9}\".utf8)  \/\/ ‚úÖ","city.parse(\"San Jose\\u{0301}\".utf8) \/\/ ‚ùå"]},{"inlineContent":[{"type":"text","text":"One way to fix this would be to add another case to the "},{"type":"codeVoice","code":"OneOf"},{"type":"text","text":" for this alternate representation"},{"type":"text","text":" "},{"type":"text","text":"of ‚ÄúSan Jos√©‚Äù:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let city = OneOf {","  \"Los Angeles\".utf8.map { City.losAngeles }","  \"New York\".utf8.map { City.newYork }","  \"San Jos\\u{00E9}\".utf8.map { City.sanJose }","  \"San Jose\\u{0301}\".utf8.map { City.sanJose }","}","","city.parse(\"San Jos\\u{00E9}\".utf8)  \/\/ ‚úÖ","city.parse(\"San Jose\\u{0301}\".utf8) \/\/ ‚úÖ"]},{"inlineContent":[{"type":"text","text":"This does work, but you are now responsible for understanding the ins and outs of UTF-8"},{"type":"text","text":" "},{"type":"text","text":"normalization. UTF-8 is incredibly complex and Swift does a lot of work to hide that complexity"},{"type":"text","text":" "},{"type":"text","text":"from you."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, there‚Äôs no need to parse everything on the level of "},{"type":"codeVoice","code":"Substring"},{"type":"text","text":" just because this one"},{"type":"text","text":" "},{"type":"text","text":"parser needs to. We can parse everything on the level of "},{"type":"codeVoice","code":"UTF8View"},{"type":"text","text":" and then parse just ‚ÄúSan Jos√©‚Äù"},{"type":"text","text":" "},{"type":"text","text":"on the level of "},{"type":"codeVoice","code":"Substring"},{"type":"text","text":". We do this by using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/FromSubstring"},{"type":"text","text":" parser, which allows us to"},{"type":"text","text":" "},{"type":"text","text":"temporarily leave the "},{"type":"codeVoice","code":"UTF8View"},{"type":"text","text":" world to work in the "},{"type":"codeVoice","code":"Substring"},{"type":"text","text":" world:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let city = OneOf {","  \"Los Angeles\".utf8.map { City.losAngeles }","  \"New York\".utf8.map { City.newYork }","  FromSubstring { \"San Jos√©\" }.map { City.sanJose }","}","","city.parse(\"San Jos\\u{00E9}\".utf8)  \/\/ ‚úÖ","city.parse(\"San Jose\\u{0301}\".utf8) \/\/ ‚úÖ"]},{"inlineContent":[{"text":"This will run the ‚ÄúSan Jos√©‚Äù parser on the level of ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":", meaning it will handle all the","type":"text"},{"text":" ","type":"text"},{"text":"complexities of UTF8 normalization so that we don‚Äôt have to think about it.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If we want to be ","type":"text"},{"inlineContent":[{"type":"text","text":"really"}],"type":"emphasis"},{"text":" pedantic we can even decide to parse only the ‚Äú√©‚Äù character on the","type":"text"},{"text":" ","type":"text"},{"text":"level of ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":" and leave everything else to ","type":"text"},{"code":"UTF8View","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let city = OneOf {","  \"Los Angeles\".utf8.map { City.losAngeles }","  \"New York\".utf8.map { City.newYork }","  Parse {","    \"San Jos\".utf8","    FromSubstring { \"√©\" }","  }","  .map { City.sanJose }","}","","city.parse(\"San Jos\\u{00E9}\".utf8)  \/\/ ‚úÖ","city.parse(\"San Jose\\u{0301}\".utf8) \/\/ ‚úÖ"]},{"inlineContent":[{"text":"We don‚Äôt necessarily recommend being this pedantic in general, at least not without benchmarking to","type":"text"},{"text":" ","type":"text"},{"text":"make sure it is worth it. But it does demonstrate how you can be very precise with which abstraction","type":"text"},{"text":" ","type":"text"},{"text":"levels you want to work on.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"seeAlsoSections":[{"identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/GettingStarted","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking"],"title":"Articles","generated":true}],"abstract":[{"type":"text","text":"Learn how to write parsers on different levels of string abstractions, giving you the ability to"},{"type":"text","text":" "},{"type":"text","text":"trade performance for correctness where needed."}],"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"],["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"]]},"kind":"article","schemaVersion":{"major":0,"patch":0,"minor":2},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions"},"sections":[],"metadata":{"role":"article","roleHeading":"Article","modules":[{"name":"Parsing"}],"title":"String Abstractions"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/parsing\/stringabstractions"]}],"references":{"doc://co.pointfree.Parsing/documentation/Parsing/Design":{"title":"Design","url":"\/documentation\/parsing\/design","kind":"article","role":"article","type":"topic","abstract":[{"text":"Learn how the library is designed, including its use of protocols, result builders and operators.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser":{"role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parser","kind":"identifier"}],"title":"Parser","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Declares a type that can incrementally parse an "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" value from an "},{"type":"codeVoice","code":"Input"},{"type":"text","text":" value."}],"navigatorTitle":[{"text":"Parser","kind":"identifier"}],"url":"\/documentation\/parsing\/parser","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"},"doc://co.pointfree.Parsing/documentation/Parsing/Backtracking":{"title":"Backtracking","url":"\/documentation\/parsing\/backtracking","kind":"article","role":"article","type":"topic","abstract":[{"text":"Learn what backtracking is, how it affects the performance of your parsers, and how to avoid it when","type":"text"},{"text":" ","type":"text"},{"text":"unnecessary.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking"},"doc://co.pointfree.Parsing/documentation/Parsing/ErrorMessages":{"title":"Error messages","url":"\/documentation\/parsing\/errormessages","kind":"article","role":"article","type":"topic","abstract":[{"text":"Learn how the library reports parsing errors and how to integrate your own custom error messages","type":"text"},{"text":" ","type":"text"},{"text":"into parsers.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages"},"doc://co.pointfree.Parsing/documentation/Parsing/GettingStarted":{"role":"article","type":"topic","url":"\/documentation\/parsing\/gettingstarted","kind":"article","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/GettingStarted","title":"Getting Started","abstract":[{"text":"Learn how to integrate Parsing into your project and write your first parser.","type":"text"}]},"doc://co.pointfree.Parsing/documentation/Parsing/FromSubstring":{"navigatorTitle":[{"kind":"identifier","text":"FromSubstring"}],"role":"symbol","url":"\/documentation\/parsing\/fromsubstring","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"FromSubstring"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/FromSubstring","type":"topic","abstract":[{"type":"text","text":"A parser that transforms a parser on "},{"type":"codeVoice","code":"Substring"},{"type":"text","text":" into a parser on another view."}],"title":"FromSubstring"},"doc://co.pointfree.Parsing/documentation/Parsing":{"role":"collection","title":"Parsing","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"A library for turning nebulous data into well-structured data, with a focus on composition,"},{"type":"text","text":" "},{"type":"text","text":"performance, generality, and ergonomics."}],"url":"\/documentation\/parsing","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"}}}