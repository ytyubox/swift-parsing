{"abstract":[{"text":"Learn how the library reports parsing errors and how to integrate your own custom error messages","type":"text"},{"text":" ","type":"text"},{"text":"into parsers.","type":"text"}],"seeAlsoSections":[{"title":"Articles","generated":true,"identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/GettingStarted","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking"]}],"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"],["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"]]},"identifier":{"url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages","interfaceLanguage":"swift"},"variants":[{"paths":["\/documentation\/parsing\/errormessages"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"schemaVersion":{"minor":2,"patch":0,"major":0},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"When a parser fails it throws an error containing information about what went wrong. The actual"},{"type":"text","text":" "},{"type":"text","text":"error thrown by the parsers shipped with this library is internal, and so it should be considered"},{"type":"text","text":" "},{"type":"text","text":"opaque. To get a human-readable debug description of the error message you can stringify the error."},{"type":"text","text":" "},{"type":"text","text":"For  example, the following "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" parser fails to parse a string that would cause it to overflow:"}]},{"type":"codeListing","code":["do {","  var input = \"1234 Hello\"[...]","  let number = try UInt8.parser().parse(&input))","} catch {","  print(error)","","  \/\/ error: failed to process \"UInt8\"","  \/\/  --> input:1:1-4","  \/\/ 1 | 1234 Hello","  \/\/   | ^^^^ overflowed 255","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the "},{"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","isActive":true},{"type":"text","text":" parser is used and fails, there are multiple errors that can be shown. "},{"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","isActive":true},{"type":"text","text":" "},{"type":"text","text":"prioritizes the error messages based on which parser got the furthest along. For example, consider"},{"type":"text","text":" "},{"type":"text","text":"a parser that can parse accounting style of numbers, i.e. plain numbers are considered positive"},{"type":"text","text":" "},{"type":"text","text":"and numbers in parentheses are considered negative:"}]},{"type":"codeListing","code":["let digits = Prefix { $0 >= \"0\" && $0 <= \"9\" }.compactMap(Int.init)","","let accountingNumber = OneOf {","  digits","","  Parse {","    \"(\"; digits; \")\"","  }","  .map { -$0 }","}","","try accountingNumber.parse(\"100\")   \/\/ 100","try accountingNumber.parse(\"(100)\") \/\/ -100"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we try parsing something erroneous, such as “(100]”, we get multiple error messages, but the"},{"type":"text","text":" "},{"type":"text","text":"second parser’s error shows first since it was able to get the furthest:"}]},{"type":"codeListing","code":["do {","  try accountingNumber.parse(\"(100]\")","} catch {","  print(error)","","  \/\/ error: multiple failures occurred","  \/\/","  \/\/ error: unexpected input","  \/\/  --> input:1:5","  \/\/ 1 | (100]","  \/\/   |     ^ expected \")\"","  \/\/","  \/\/ error: unexpected input","  \/\/  --> input:1:1","  \/\/ 1 | (100]","  \/\/   | ^ expected integer","}"],"syntax":"swift"},{"type":"heading","text":"Improving error messages","anchor":"Improving-error-messages","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The quality of error messages emitted by a parser can depend on the manner in which the parser was"},{"type":"text","text":" "},{"type":"text","text":"constructed. Some parser operators are powerful and convenient, but can cause the quality of error"},{"type":"text","text":" "},{"type":"text","text":"messaging to degrade."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, we could construct a parser that consumes a single uncommented line from an input"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"emphasis","inlineContent":[{"type":"text","text":"i.e."}]},{"type":"text","text":", a line that does not begin with “\/\/”) by using "},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/compactMap(_:)","isActive":true,"type":"reference"},{"type":"text","text":" to check the line"},{"type":"text","text":" "},{"type":"text","text":"for a  prefix:"}]},{"type":"codeListing","code":["let uncommentedLine = Prefix { $0 != \"\\n\" }","  .compactMap { $0.starts(with: \"\/\/\") ? nil : $0 }","","try uncommentedLine.parse(\"\/\/ let x = 1\")","","\/\/ error: failed to process \"Substring\" from \"\/\/ let x = 1\"","\/\/  --> input:1:1-12","\/\/ 1 | \/\/ let x = 1","\/\/   | ^^^^^^^^^^^^"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, when this parser fails it can only highlight the entire line as having a problem because"},{"type":"text","text":" "},{"type":"text","text":"it cannot know that the only thing that failed was that the first two characters were slashes."}]},{"type":"paragraph","inlineContent":[{"text":"We can rewrite this parser in a different, but equivalent, way by using the ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Not","type":"reference","isActive":true},{"text":" parser to first","type":"text"},{"text":" ","type":"text"},{"text":"confirm that the line does not begin with “\/\/”, and then consume the entire line:","type":"text"}]},{"type":"codeListing","code":["let uncommentedLine = Parse {","  Not { \"\/\/\" }","  Prefix { $0 != \"\\n\" }","}","","try uncommentedLine.parse(\"\/\/ let x = 1\")","","\/\/ error: unexpected input","\/\/  --> input:1:1-2","\/\/ 1 | \/\/ let x = 1","\/\/   | ^^ expected not to be processed"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This provides better error messaging because "},{"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Not","isActive":true},{"type":"text","text":" knows exactly what matched that we did not want"},{"type":"text","text":" "},{"type":"text","text":"to match, and so it can highlight those specific characters."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When using the "},{"code":"Many","type":"codeVoice"},{"type":"text","text":" parser you can improve error messaging by supplying a “terminator” parser,"},{"type":"text","text":" "},{"type":"text","text":"which is an optional argument. The terminator parser is run after the element and separator"},{"type":"text","text":" "},{"type":"text","text":"parsers have consumed as much as they can, and allows you to assert on exactly what is left"},{"type":"text","text":" "},{"type":"text","text":"afterwards."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if a parser is run on an input that has a typo in the last row of data, and a"},{"type":"text","text":" "},{"type":"text","text":"terminator is not specified, the parser will succeed without consuming that last row and we won’t"},{"type":"text","text":" "},{"type":"text","text":"know what went wrong:"}]},{"type":"codeListing","code":["struct User {","  var id: Int","  var name: String","  var isAdmin: Bool","}","","let user = Parse(User.init(id:name:isAdmin:)) {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }.map(String.init)","  \",\"","  Bool.parser()","}","","let users = Many {","  user","} separator: {","  \"\\n\"","}","","var input = \"\"\"","1,Blob,true","2,Blob Jr.,false","3,Blob Sr.,tru","\"\"\"[...]","","let output = try users.parse(&input)","output.count \/\/ 2","input \/\/ \"\\n3,Blob Sr.,tru\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"However, by adding a terminator to this ","type":"text"},{"type":"codeVoice","code":"users"},{"text":" parser an error will be throw that points to the","type":"text"},{"text":" ","type":"text"},{"text":"exact spot where the typo occurred:","type":"text"}]},{"type":"codeListing","code":["let users = Many {","  user","} separator: {","  \"\\n\"","} terminator: {","  End()","}","","let output = try users.parse(&input)","","\/\/ error: unexpected input","\/\/  --> input:3:11","\/\/ 3 | 3,Blob Jr,tru","\/\/   |           ^ expected \"true\" or \"false\""],"syntax":"swift"},{"type":"heading","text":"Throwing your own errors","anchor":"Throwing-your-own-errors","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Although the error type thrown by the parsers that ship in this library is currently internal, and"},{"type":"text","text":" "},{"type":"text","text":"so should be thought of as opaque, it is still possible to throw your own errors. Your errors will"},{"type":"text","text":" "},{"type":"text","text":"automatically be reformatted and contextualized to show exactly where the error occurred."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose we wanted a parser that only parsed the digits 0-9 from the beginning of a"},{"type":"text","text":" "},{"type":"text","text":"string and transformed it into an integer. This is subtly different from "},{"code":"Int.parser()","type":"codeVoice"},{"type":"text","text":" which"},{"type":"text","text":" "},{"type":"text","text":"supports negative numbers, exponential formatting, and more."}]},{"type":"paragraph","inlineContent":[{"text":"Constructing a ","type":"text"},{"type":"codeVoice","code":"Digits"},{"text":" parser is easy enough, and we can introduce a custom struct error for","type":"text"},{"text":" ","type":"text"},{"text":"customizing the message displayed:","type":"text"}]},{"type":"codeListing","code":["struct DigitsError: Error {","  let message = \"Expected a prefix of digits 0-9\"","}","","struct Digits: Parser {","  func parse(_ input: inout Substring) throws -> Int {","    let digits = input.prefix { $0 >= \"0\" && $0 <= \"9\" }","    guard let output = Int(digits)","    else {","      throw DigitsError()","    }","    input.removeFirst(digits.count)","    return output","  }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"If we swap out the ","type":"text"},{"code":"Int.parser()","type":"codeVoice"},{"text":" for a ","type":"text"},{"code":"Digits","type":"codeVoice"},{"text":" parser in ","type":"text"},{"code":"user","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","code":["let user = Parse(User.init) {","  Digits()","  \",\"","  Prefix { $0 != \",\" }.map(String.init)","  \",\"","  Bool.parser()","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And we introduce an incorrect value into the input:"}]},{"type":"codeListing","code":["let input = \"\"\"","1,Blob,true","-2,Blob Jr.,false","3,Blob Sr.,true","\"\"\"[...]"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then when running the parser we get a nice error message that shows exactly what went wrong:"}]},{"type":"codeListing","code":["try user.parse(&input)","","\/\/ error: DigitsError(message: \"Expected a prefix of digits 0-9\")","\/\/  --> input:2:1","\/\/ 2 | -2,Blob Sr,false","\/\/   | ^"],"syntax":"swift"}]}],"metadata":{"role":"article","modules":[{"name":"Parsing"}],"title":"Error messages","roleHeading":"Article"},"kind":"article","references":{"doc://co.pointfree.Parsing/documentation/Parsing/Design":{"title":"Design","url":"\/documentation\/parsing\/design","kind":"article","role":"article","type":"topic","abstract":[{"text":"Learn how the library is designed, including its use of protocols, result builders and operators.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf":{"abstract":[{"text":"A parser that attempts to run a number of parsers till one succeeds.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"type":"topic","url":"\/documentation\/parsing\/oneof","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"}],"title":"OneOf","role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser":{"role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parser","kind":"identifier"}],"title":"Parser","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Declares a type that can incrementally parse an "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" value from an "},{"type":"codeVoice","code":"Input"},{"type":"text","text":" value."}],"navigatorTitle":[{"text":"Parser","kind":"identifier"}],"url":"\/documentation\/parsing\/parser","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"},"doc://co.pointfree.Parsing/documentation/Parsing/Backtracking":{"title":"Backtracking","url":"\/documentation\/parsing\/backtracking","kind":"article","role":"article","type":"topic","abstract":[{"text":"Learn what backtracking is, how it affects the performance of your parsers, and how to avoid it when","type":"text"},{"text":" ","type":"text"},{"text":"unnecessary.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking"},"doc://co.pointfree.Parsing/documentation/Parsing/Not":{"navigatorTitle":[{"text":"Not","kind":"identifier"}],"abstract":[{"text":"A parser that succeeds if the given parser fails, and does not consume any input.","type":"text"}],"url":"\/documentation\/parsing\/not","title":"Not","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Not","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Not","kind":"identifier"}],"role":"symbol","type":"topic","kind":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser/compactMap(_:)":{"kind":"symbol","title":"compactMap(_:)","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"compactMap","kind":"identifier"},{"text":"<","kind":"text"},{"kind":"genericParameter","text":"NewOutput"},{"kind":"text","text":">(("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Output"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"NewOutput"},{"text":"?) -> ","kind":"text"},{"preciseIdentifier":"s:7Parsing7ParsersO","text":"Parsers","kind":"typeIdentifier"},{"text":".","kind":"text"},{"preciseIdentifier":"s:7Parsing7ParsersO10CompactMapV","text":"CompactMap","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"NewOutput","kind":"typeIdentifier"},{"text":">","kind":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/compactMap(_:)","abstract":[{"text":"Returns a parser that outputs the non-","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" result of calling the given closure with the"},{"type":"text","text":" "},{"type":"text","text":"output of this parser."}],"url":"\/documentation\/parsing\/parser\/compactmap(_:)","type":"topic"},"doc://co.pointfree.Parsing/documentation/Parsing/GettingStarted":{"role":"article","type":"topic","url":"\/documentation\/parsing\/gettingstarted","kind":"article","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/GettingStarted","title":"Getting Started","abstract":[{"text":"Learn how to integrate Parsing into your project and write your first parser.","type":"text"}]},"doc://co.pointfree.Parsing/documentation/Parsing":{"role":"collection","title":"Parsing","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"A library for turning nebulous data into well-structured data, with a focus on composition,"},{"type":"text","text":" "},{"type":"text","text":"performance, generality, and ergonomics."}],"url":"\/documentation\/parsing","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"},"doc://co.pointfree.Parsing/documentation/Parsing/StringAbstractions":{"url":"\/documentation\/parsing\/stringabstractions","kind":"article","type":"topic","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","abstract":[{"type":"text","text":"Learn how to write parsers on different levels of string abstractions, giving you the ability to"},{"type":"text","text":" "},{"type":"text","text":"trade performance for correctness where needed."}],"title":"String Abstractions","role":"article"}}}