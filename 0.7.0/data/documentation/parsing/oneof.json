{"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"]]},"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"OneOf"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Parsers"},{"kind":"text","text":"> "},{"kind":"keyword","text":"where"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"Parsers"},{"kind":"text","text":" : "},{"kind":"typeIdentifier","preciseIdentifier":"s:7Parsing6ParserP","text":"Parser","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"}],"languages":["swift"],"platforms":["Linux"]}]},{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use this parser to list out a number of parsers in a "},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOfBuilder","type":"reference","isActive":true},{"type":"text","text":" result builder block."}]},{"type":"paragraph","inlineContent":[{"text":"The following example uses ","type":"text"},{"code":"OneOf","type":"codeVoice"},{"text":" to parse an enum value. To do so, it spells out a list of","type":"text"},{"text":" ","type":"text"},{"text":"parsers to ","type":"text"},{"code":"OneOf","type":"codeVoice"},{"text":", one for each case:","type":"text"}]},{"type":"codeListing","code":["enum Currency { case eur, gbp, usd }","","let currency = OneOf {","  \"€\".map { Currency.eur }","  \"£\".map { Currency.gbp }","  \"$\".map { Currency.usd }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This parser fails if every parser inside fails:"}]},{"type":"codeListing","code":["var input = \"London, Hello!\"[...]","try OneOf { \"New York\"; \"Berlin\" }.parse(&input)","","\/\/ error: multiple failures occurred","\/\/","\/\/ error: unexpected input","\/\/  --> input:1:1","\/\/ 1 | London, Hello!","\/\/   | ^ expected \"New York\"","\/\/","\/\/ error: unexpected input","\/\/  --> input:1:1","\/\/ 1 | London, Hello!","\/\/   | ^ expected \"Berlin\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"If you are parsing input that should coalesce into some default, avoid using a final ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Always"},{"text":" ","type":"text"},{"text":"parser, and instead opt for a trailing ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/replaceError(with:)"},{"text":", which returns a parser that","type":"text"},{"text":" ","type":"text"},{"text":"cannot fail:","type":"text"}]},{"type":"codeListing","code":["enum Currency { case eur, gbp, usd, unknown }","","let currency = OneOf {","  \"€\".map { Currency.eur }","  \"£\".map { Currency.gbp }","  \"$\".map { Currency.usd }","}",".replaceError(with: Currency.unknown)","","currency.parse(\"$\")  \/\/ Currency.usd","currency.parse(\"฿\")  \/\/ Currency.unknown"],"syntax":"swift"},{"type":"heading","level":1,"text":"Backtracking","anchor":"Backtracking"},{"type":"paragraph","inlineContent":[{"code":"OneOf","type":"codeVoice"},{"text":" will automatically revert any changes made to input when one of its parsers fails. This","type":"text"},{"text":" ","type":"text"},{"text":"process is often called “backtracking”, and simplifies the logic of other parsers by not forcing","type":"text"},{"text":" ","type":"text"},{"text":"them to be responsible for their own backtracking when they fail.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If used naively, backtracking can lead to less performant parsing code. For example, if we"},{"type":"text","text":" "},{"type":"text","text":"wanted to parse two integers from a string that were separated by either a dash “-” or slash"},{"type":"text","text":" "},{"type":"text","text":"“\/”, then we could write this as:"}]},{"type":"codeListing","code":["OneOf {","  Parser { Int.parser(); \"-\"; Int.parser() } \/\/ 1️⃣","  Parser { Int.parser(); \"\/\"; Int.parser() } \/\/ 2️⃣","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"However, parsing slash-separated integers is not going to be performant because it will first","type":"text"},{"text":" ","type":"text"},{"text":"run the entire 1️⃣ parser until it fails, then backtrack to the beginning, and run the 2️⃣ parser.","type":"text"},{"text":" ","type":"text"},{"text":"In particular, the first integer will get parsed twice, unnecessarily repeating that work.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"On the other hand, we can factor out the common work of the parser and localize the backtracking"},{"type":"text","text":" "},{"type":"codeVoice","code":"OneOf"},{"type":"text","text":" work to make a much more performant parser:"}]},{"type":"codeListing","code":["Parse {","  Int.parser()","  OneOf { \"-\"; \"\/\" }","  Int.parser()","}"],"syntax":"swift"}],"kind":"content"}],"abstract":[{"text":"A parser that attempts to run a number of parsers till one succeeds.","type":"text"}],"sections":[],"topicSections":[{"title":"Initializers","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/init(_:)"]},{"title":"Instance Properties","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parsers"]},{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parse(_:)"]},{"title":"Default Implementations","generated":true,"identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/Parser-Implementations"]}],"variants":[{"paths":["\/documentation\/parsing\/oneof"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"title":"OneOf","role":"symbol","modules":[{"name":"Parsing"}],"symbolKind":"struct","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"OneOf"}],"navigatorTitle":[{"kind":"identifier","text":"OneOf"}],"externalID":"s:7Parsing5OneOfV","roleHeading":"Structure"},"identifier":{"url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","interfaceLanguage":"swift"},"schemaVersion":{"minor":2,"major":0,"patch":0},"kind":"symbol","relationshipsSections":[{"kind":"relationships","title":"Conforms To","type":"conformsTo","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"]}],"references":{"doc://co.pointfree.Parsing/documentation/Parsing/OneOfBuilder":{"type":"topic","abstract":[{"type":"text","text":"A custom parameter attribute that constructs a parser that attempts to run a number of parsers,"},{"type":"text","text":" "},{"text":"one after the other, till one succeeds with an output.","type":"text"}],"kind":"symbol","title":"OneOfBuilder","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOfBuilder","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOfBuilder","kind":"identifier"}],"role":"symbol","navigatorTitle":[{"text":"OneOfBuilder","kind":"identifier"}],"url":"\/documentation\/parsing\/oneofbuilder"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/parse(_:)":{"type":"topic","abstract":[{"text":"Attempts to parse a nebulous piece of data into something more well-structured.","type":"text"}],"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"parse"},{"kind":"text","text":"("},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"Parsers"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Input"},{"kind":"text","text":") "},{"kind":"keyword","text":"rethrows"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Parsers"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Output"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parse(_:)","kind":"symbol","url":"\/documentation\/parsing\/oneof\/parse(_:)","role":"symbol","title":"parse(_:)"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf":{"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"}],"navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"role":"symbol","type":"topic","abstract":[{"text":"A parser that attempts to run a number of parsers till one succeeds.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","title":"OneOf","url":"\/documentation\/parsing\/oneof"},"doc://co.pointfree.Parsing/documentation/Parsing/Always":{"abstract":[{"text":"A parser that always succeeds with the given value, and does not consume any input.","type":"text"}],"title":"Always","url":"\/documentation\/parsing\/always","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Always"}],"navigatorTitle":[{"kind":"identifier","text":"Always"}],"kind":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Always","role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/parsers":{"fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"text":"parsers","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parsers","kind":"symbol","url":"\/documentation\/parsing\/oneof\/parsers","role":"symbol","title":"parsers","abstract":[],"type":"topic"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/init(_:)":{"type":"topic","abstract":[],"fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"(() -> "},{"kind":"typeIdentifier","text":"Parsers"},{"kind":"text","text":")"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/init(_:)","kind":"symbol","url":"\/documentation\/parsing\/oneof\/init(_:)","role":"symbol","title":"init(_:)"},"doc://co.pointfree.Parsing/documentation/Parsing":{"url":"\/documentation\/parsing","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","type":"topic","abstract":[],"kind":"symbol","title":"Parsing","role":"collection"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/Parser-Implementations":{"kind":"article","role":"collectionGroup","type":"topic","abstract":[],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/Parser-Implementations","title":"Parser Implementations","url":"\/documentation\/parsing\/oneof\/parser-implementations"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser":{"abstract":[{"type":"text","text":"Declares a type that can parse an "},{"code":"Input","type":"codeVoice"},{"type":"text","text":" value into an "},{"code":"Output","type":"codeVoice"},{"type":"text","text":" value."}],"url":"\/documentation\/parsing\/parser","title":"Parser","type":"topic","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Parser"}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Parser"}],"kind":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/replaceError(with:)":{"url":"\/documentation\/parsing\/oneof\/replaceerror(with:)","role":"symbol","type":"topic","abstract":[{"text":"A parser that replaces its error with a provided output.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/replaceError(with:)","title":"replaceError(with:)","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"replaceError","kind":"identifier"},{"text":"(","kind":"text"},{"text":"with","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Output","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier","preciseIdentifier":"s:7Parsing7ParsersO"},{"text":".","kind":"text"},{"text":"ReplaceError","kind":"typeIdentifier","preciseIdentifier":"s:7Parsing7ParsersO12ReplaceErrorV"},{"text":"<","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":">","kind":"text"}]}}}