{"metadata":{"roleHeading":"Article","modules":[{"name":"Parsing"}],"role":"article","title":"Backtracking"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/parsing\/backtracking"]}],"abstract":[{"type":"text","text":"Learn what backtracking is, how it affects the performance of your parsers, and how to avoid it when"},{"type":"text","text":" "},{"type":"text","text":"unnecessary."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking"},"schemaVersion":{"minor":3,"major":0,"patch":0},"sections":[],"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"],["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"]]},"kind":"article","primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"inlineContent":[{"text":"Backtracking is the process of restoring an input to its original value when parsing fails. While it","type":"text"},{"text":" ","type":"text"},{"text":"can be very useful, backtracking can lead to more complicated parser logic than necessary, and","type":"text"},{"text":" ","type":"text"},{"text":"backtracking too often can lead to performance issues. For this reason, most parsers are not","type":"text"},{"text":" ","type":"text"},{"text":"required to backtrack, and can therefore fail ","type":"text"},{"inlineContent":[{"type":"text","text":"and"}],"type":"emphasis"},{"text":" still consume from the input.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The primary way to make use of backtracking in your parsers is through the ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf"},{"text":" parser, which","type":"text"},{"text":" ","type":"text"},{"text":"tries many parsers on an input and chooses the first that succeeds. This allows you to try many","type":"text"},{"text":" ","type":"text"},{"text":"parsers on the same input, regardless of how much each parser consumes:","type":"text"}],"type":"paragraph"},{"code":["enum Currency { case eur, gbp, usd }","","let currency = OneOf {","  \"€\".map { Currency.eur }","  \"£\".map { Currency.gbp }","  \"$\".map { Currency.usd }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"When to backtrack in your parsers?","type":"heading","anchor":"When-to-backtrack-in-your-parsers?"},{"inlineContent":[{"text":"If you only use the parsers and operators that ship with this library, and in particular you do not","type":"text"},{"text":" ","type":"text"},{"text":"create custom conformances to the ","type":"text"},{"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","isActive":true},{"text":" protocol, then you never need to worry about explicitly","type":"text"},{"text":" ","type":"text"},{"text":"backtracking your input because it will be handled for you automatically. The primary way to allow","type":"text"},{"text":" ","type":"text"},{"text":"for backtracking is via the ","type":"text"},{"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","isActive":true},{"text":" parser, but there are a few other parsers that also backtrack","type":"text"},{"text":" ","type":"text"},{"text":"internally.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"One such example is the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Optionally"},{"type":"text","text":" parser, which transforms any parser into one that cannot fail"},{"type":"text","text":" "},{"type":"text","text":"by catching any thrown errors and returning "},{"type":"codeVoice","code":"nil"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["let parser = Parse {","  \"Hello,\"","  Optionally { \" \"; Bool.parser() }","  \" world!\"","}","","try parser.parse(\"Hello, world!\")      \/\/ nil","try parser.parse(\"Hello, true world!\") \/\/ true"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"If the parser captured inside "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Optionally"},{"type":"text","text":" fails then it backtracks the input to its state before"},{"type":"text","text":" "},{"type":"text","text":"the parser ran. In particular, if the "},{"code":"Bool.parser()","type":"codeVoice"},{"type":"text","text":" fails then it will make sure to undo"},{"type":"text","text":" "},{"type":"text","text":"consuming the leading space “ “ so that later parsers can try."}],"type":"paragraph"},{"inlineContent":[{"text":"Another example of a parser that internally backtracks is the ","type":"text"},{"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/replaceError(with:)","isActive":true},{"text":" ","type":"text"},{"text":"operator, which coalesces any error thrown by a parser into a default output value:","type":"text"}],"type":"paragraph"},{"code":["let parser = Parse {","  \"Hello,\"","  Optionally { \" \"; Bool.parser() }","    .replaceError(with: false)","  \" world!\"","}","","try parser.parse(\"Hello, world!\")      \/\/ false","try parser.parse(\"Hello, true world!\") \/\/ true"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"It backtracks the input to its original value when the parser fails so that later parsers can try.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The only time you need to worry about explicitly backtracking input is when making your own"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"},{"type":"text","text":" conformances. As a general rule of thumb, if your parser recovers from all failures"},{"type":"text","text":" "},{"type":"text","text":"in the "},{"code":"parse","type":"codeVoice"},{"type":"text","text":" method then it should backtrack the input to its state before the error was thrown."},{"type":"text","text":" "},{"type":"text","text":"This is exactly how "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Optionally"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/replaceError(with:)"},{"type":"text","text":" work."}],"type":"paragraph"},{"level":2,"text":"Performance","type":"heading","anchor":"Performance"},{"inlineContent":[{"type":"text","text":"If used naively, backtracking can lead to less performant parsing code. For example, if we wanted to"},{"type":"text","text":" "},{"type":"text","text":"parse two integers from a string that were separated by either a dash “-” or slash “\/”, then we"},{"type":"text","text":" "},{"type":"text","text":"could write this as:"}],"type":"paragraph"},{"code":["OneOf {","  Parse { Int.parser(); \"-\"; Int.parser() } \/\/ 1️⃣","  Parse { Int.parser(); \"\/\"; Int.parser() } \/\/ 2️⃣","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"However, parsing slash-separated integers is not going to be performant because it will first run"},{"type":"text","text":" "},{"type":"text","text":"the entire 1️⃣ parser until it fails, then backtrack to the beginning, and run the 2️⃣ parser. In"},{"type":"text","text":" "},{"type":"text","text":"particular, the first integer will get parsed twice, unnecessarily repeating that work."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"On the  other hand, we can factor out the common work of the parser and localize the backtracking"},{"type":"text","text":" "},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","type":"reference","isActive":true},{"type":"text","text":" work to make a much more performant parser:"}],"type":"paragraph"},{"code":["Parse {","  Int.parser()","  OneOf { \"-\"; \"\/\" }","  Int.parser()","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"We can even write a benchmark to measure the performance difference:"}],"type":"paragraph"},{"code":["let first = OneOf {","  Parse { Int.parser(); \"-\"; Int.parser() }","  Parse { Int.parser(); \"\/\"; Int.parser() }","}","benchmark(\"First\") {","  precondition(try! first.parse(\"100\/200\") == (100, 200))","}","let second = Parse {","  Int.parser()","  OneOf { \"-\"; \"\/\" }","  Int.parser()","}","benchmark(\"Second\") {","  precondition(try! second.parse(\"100\/200\") == (100, 200))","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Running this produces the following results:"}],"type":"paragraph"},{"code":["name   time        std        iterations","----------------------------------------","First  1500.000 ns ±  19.75 %     856753","Second  917.000 ns ±  15.89 %    1000000"],"type":"codeListing","syntax":null},{"inlineContent":[{"type":"text","text":"The second parser takes only 60% of the time to run that the first parser does."}],"type":"paragraph"}]}],"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/GettingStarted","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages"],"title":"Articles"}],"references":{"doc://co.pointfree.Parsing/documentation/Parsing/Optionally":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Optionally"}],"abstract":[{"text":"A parser that runs the given parser and succeeds with ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" if it fails.","type":"text"}],"title":"Optionally","navigatorTitle":[{"kind":"identifier","text":"Optionally"}],"kind":"symbol","role":"symbol","url":"\/documentation\/parsing\/optionally","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Optionally","type":"topic"},"doc://co.pointfree.Parsing/documentation/Parsing/ErrorMessages":{"role":"article","kind":"article","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages","abstract":[{"text":"Learn how the library reports parsing errors and how to integrate your own custom error messages","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"into parsers."}],"type":"topic","url":"\/documentation\/parsing\/errormessages","title":"Error Messages"},"doc://co.pointfree.Parsing/documentation/Parsing/GettingStarted":{"role":"article","kind":"article","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/GettingStarted","abstract":[{"text":"Learn how to integrate Parsing into your project and write your first parser.","type":"text"}],"type":"topic","url":"\/documentation\/parsing\/gettingstarted","title":"Getting Started"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser/replaceError(with:)":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/replaceError(with:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"replaceError"},{"kind":"text","text":"("},{"kind":"externalParam","text":"with"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Output"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Parsers","preciseIdentifier":"s:7Parsing7ParsersO"},{"text":".","kind":"text"},{"text":"ReplaceError","preciseIdentifier":"s:7Parsing7ParsersO12ReplaceErrorV","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":">","kind":"text"}],"title":"replaceError(with:)","url":"\/documentation\/parsing\/parser\/replaceerror(with:)","kind":"symbol","type":"topic","abstract":[{"text":"A parser that replaces its error with a provided output.","type":"text"}],"role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","title":"Parsing","role":"collection","type":"topic","url":"\/documentation\/parsing","abstract":[{"text":"A library for turning nebulous data into well-structured data, with a focus on composition,","type":"text"},{"text":" ","type":"text"},{"text":"performance, generality, and ergonomics.","type":"text"}],"kind":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser":{"abstract":[{"type":"text","text":"Declares a type that can incrementally parse an "},{"code":"Output","type":"codeVoice"},{"type":"text","text":" value from an "},{"type":"codeVoice","code":"Input"},{"text":" value.","type":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Parser"}],"kind":"symbol","url":"\/documentation\/parsing\/parser","navigatorTitle":[{"kind":"identifier","text":"Parser"}],"type":"topic","role":"symbol","title":"Parser"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf":{"navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"abstract":[{"text":"A parser that attempts to run a number of parsers till one succeeds.","type":"text"}],"type":"topic","title":"OneOf","kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","url":"\/documentation\/parsing\/oneof"},"doc://co.pointfree.Parsing/documentation/Parsing/StringAbstractions":{"title":"String Abstractions","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","abstract":[{"type":"text","text":"Learn how to write parsers on different levels of string abstractions, giving you the ability to"},{"type":"text","text":" "},{"type":"text","text":"trade performance for correctness where needed."}],"kind":"article","type":"topic","role":"article","url":"\/documentation\/parsing\/stringabstractions"},"doc://co.pointfree.Parsing/documentation/Parsing/Design":{"role":"article","kind":"article","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design","abstract":[{"text":"Learn how the library is designed, including its use of protocols, result builders and operators.","type":"text"}],"type":"topic","url":"\/documentation\/parsing\/design","title":"Design"}}}