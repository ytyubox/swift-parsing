{"schemaVersion":{"patch":0,"minor":2,"major":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf"},"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"]]},"abstract":[{"type":"text","text":"A parser that attempts to run a number of parsers till one succeeds."}],"primaryContentSections":[{"declarations":[{"platforms":["Linux"],"tokens":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Parsers","kind":"genericParameter"},{"text":"> ","kind":"text"},{"text":"where","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier"},{"text":" : ","kind":"text"},{"preciseIdentifier":"s:7Parsing6ParserP","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","text":"Parser","kind":"typeIdentifier"}],"languages":["swift"]}],"kind":"declarations"},{"kind":"content","content":[{"level":2,"anchor":"overview","text":"Overview","type":"heading"},{"code":["enum Currency { case eur, gbp, usd }","","let currency = OneOf {","  \"€\".map { Currency.eur }","  \"£\".map { Currency.gbp }","  \"$\".map { Currency.usd }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"If you are optionally parsing input that should coalesce into some default, you can skip the","type":"text"},{"text":" ","type":"text"},{"text":"optionality and instead use ","type":"text"},{"code":"OneOf","type":"codeVoice"},{"text":" with an ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Always"},{"text":" parser, given a default:","type":"text"}]},{"code":["enum Currency { case eur, gbp, usd, unknown }","","let currency = OneOf {","  \"€\".map { Currency.eur }","  \"£\".map { Currency.gbp }","  \"$\".map { Currency.usd }","  Always(Currency.unknown)","}"],"syntax":"swift","type":"codeListing"},{"level":1,"anchor":"Backtracking","text":"Backtracking","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"OneOf"},{"type":"text","text":" will automatically revert any changes made to input when one of its parsers fails. This"},{"type":"text","text":" "},{"type":"text","text":"process is often called “backtracking”, and simplifies the logic of other parsers by not forcing them"},{"type":"text","text":" "},{"type":"text","text":"to be responsible for their own backtracking when they fail."}]},{"type":"paragraph","inlineContent":[{"text":"If used naively, backtracking can lead to less performant parsing code. For example, if we wanted to parse","type":"text"},{"text":" ","type":"text"},{"text":"two integers from a string that were separated by either a dash “-” or slash “\/”, then we could write this","type":"text"},{"text":" ","type":"text"},{"text":"as:","type":"text"}]},{"code":["OneOf {","  Parser { Int.parser(); \"-\"; Int.parser() } \/\/ 1️⃣","  Parser { Int.parser(); \"\/\"; Int.parser() } \/\/ 2️⃣","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, parsing slash-separated integers is not going to be performant because it will first run the"},{"type":"text","text":" "},{"type":"text","text":"entire 1️⃣ parser until it fails, then backtrack to the beginning, and run the 2️⃣ parser. In particular,"},{"type":"text","text":" "},{"type":"text","text":"the first integer will get parsed twice, unnecessarily repeating that work."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"On the other hand, we can factor out the common work of the parser and localize the backtracking "},{"type":"codeVoice","code":"OneOf"},{"type":"text","text":" "},{"type":"text","text":"work to make a much more performant parser:"}]},{"code":["Parse {","  Int.parser()","  OneOf { \"-\"; \"\/\" }","  Int.parser()","}"],"syntax":"swift","type":"codeListing"}]}],"metadata":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"}],"role":"symbol","symbolKind":"struct","roleHeading":"Structure","title":"OneOf","externalID":"s:7Parsing5OneOfV","navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"modules":[{"name":"Parsing"}]},"kind":"symbol","topicSections":[{"title":"Initializers","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/init(_:)"]},{"identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parsers"],"title":"Instance Properties"},{"identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parse(_:)"],"title":"Instance Methods"},{"identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/Parser-Implementations"],"generated":true,"title":"Default Implementations"}],"relationshipsSections":[{"type":"conformsTo","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"],"kind":"relationships","title":"Conforms To"}],"variants":[{"paths":["\/documentation\/parsing\/oneof"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"references":{"doc://co.pointfree.Parsing/documentation/Parsing/Always":{"title":"Always","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Always","kind":"symbol","abstract":[{"text":"A parser that always succeeds by returning the provided value, but does not consume any of its","type":"text"},{"text":" ","type":"text"},{"text":"input.","type":"text"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Always"}],"url":"\/documentation\/parsing\/always","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Always"}],"type":"topic"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/parsers":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parsers","abstract":[],"type":"topic","fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"parsers"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Parsers"}],"title":"parsers","kind":"symbol","url":"\/documentation\/parsing\/oneof\/parsers","role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/init(_:)":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/init(_:)","abstract":[],"type":"topic","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"(() -> "},{"kind":"typeIdentifier","text":"Parsers"},{"kind":"text","text":")"}],"title":"init(_:)","kind":"symbol","url":"\/documentation\/parsing\/oneof\/init(_:)","role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/parse(_:)":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parse(_:)","abstract":[{"type":"text","text":"Attempts to parse a nebulous piece of data into something more well-structured."}],"type":"topic","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"parse"},{"kind":"text","text":"("},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Output","kind":"typeIdentifier"},{"text":"?","kind":"text"}],"title":"parse(_:)","kind":"symbol","url":"\/documentation\/parsing\/oneof\/parse(_:)","role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","title":"OneOf","abstract":[{"type":"text","text":"A parser that attempts to run a number of parsers till one succeeds."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/parsing\/oneof","type":"topic","navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser":{"title":"Parser","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","url":"\/documentation\/parsing\/parser","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Parser"}],"abstract":[{"type":"text","text":"Declares a type that can parse an "},{"type":"codeVoice","code":"Input"},{"type":"text","text":" value into an "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" value."}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Parser"}],"role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing":{"title":"Parsing","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","url":"\/documentation\/parsing","type":"topic","kind":"symbol","abstract":[],"role":"collection"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/Parser-Implementations":{"title":"Parser Implementations","role":"collectionGroup","type":"topic","url":"\/documentation\/parsing\/oneof\/parser-implementations","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/Parser-Implementations","kind":"article","abstract":[]}}}