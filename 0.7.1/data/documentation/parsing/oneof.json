{"abstract":[{"text":"A parser that attempts to run a number of parsers till one succeeds.","type":"text"}],"kind":"symbol","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf"},"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/parsing\/oneof"]}],"schemaVersion":{"minor":2,"major":0,"patch":0},"metadata":{"role":"symbol","roleHeading":"Structure","externalID":"s:7Parsing5OneOfV","modules":[{"name":"Parsing"}],"navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"title":"OneOf","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"OneOf","kind":"identifier"}],"symbolKind":"struct"},"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["Linux"],"languages":["swift"],"tokens":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Parsers","kind":"genericParameter"},{"text":"> ","kind":"text"},{"text":"where","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier"},{"text":" : ","kind":"text"},{"text":"Parser","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","kind":"typeIdentifier","preciseIdentifier":"s:7Parsing6ParserP"}]}]},{"content":[{"anchor":"overview","type":"heading","text":"Overview","level":2},{"inlineContent":[{"text":"Use this parser to list out a number of parsers in a ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOfBuilder","isActive":true,"type":"reference"},{"text":" result builder block.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The following example uses "},{"type":"codeVoice","code":"OneOf"},{"type":"text","text":" to parse an enum value. To do so, it spells out a list of"},{"type":"text","text":" "},{"type":"text","text":"parsers to "},{"type":"codeVoice","code":"OneOf"},{"type":"text","text":", one for each case:"}],"type":"paragraph"},{"code":["enum Currency { case eur, gbp, usd }","","let currency = OneOf {","  \"€\".map { Currency.eur }","  \"£\".map { Currency.gbp }","  \"$\".map { Currency.usd }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This parser fails if every parser inside fails:","type":"text"}],"type":"paragraph"},{"code":["var input = \"London, Hello!\"[...]","try OneOf { \"New York\"; \"Berlin\" }.parse(&input)","","\/\/ error: multiple failures occurred","\/\/","\/\/ error: unexpected input","\/\/  --> input:1:1","\/\/ 1 | London, Hello!","\/\/   | ^ expected \"New York\"","\/\/","\/\/ error: unexpected input","\/\/  --> input:1:1","\/\/ 1 | London, Hello!","\/\/   | ^ expected \"Berlin\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"If you are parsing input that should coalesce into some default, avoid using a final ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Always","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"parser, and instead opt for a trailing ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/replaceError(with:)","type":"reference","isActive":true},{"text":", which returns a parser that","type":"text"},{"text":" ","type":"text"},{"text":"cannot fail:","type":"text"}],"type":"paragraph"},{"code":["enum Currency { case eur, gbp, usd, unknown }","","let currency = OneOf {","  \"€\".map { Currency.eur }","  \"£\".map { Currency.gbp }","  \"$\".map { Currency.usd }","}",".replaceError(with: Currency.unknown)","","currency.parse(\"$\")  \/\/ Currency.usd","currency.parse(\"฿\")  \/\/ Currency.unknown"],"type":"codeListing","syntax":"swift"},{"anchor":"Backtracking","type":"heading","text":"Backtracking","level":1},{"inlineContent":[{"type":"codeVoice","code":"OneOf"},{"text":" will automatically revert any changes made to input when one of its parsers fails. This","type":"text"},{"text":" ","type":"text"},{"text":"process is often called “backtracking”, and simplifies the logic of other parsers by not forcing","type":"text"},{"text":" ","type":"text"},{"text":"them to be responsible for their own backtracking when they fail.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If used naively, backtracking can lead to less performant parsing code. For example, if we"},{"type":"text","text":" "},{"type":"text","text":"wanted to parse two integers from a string that were separated by either a dash “-” or slash"},{"type":"text","text":" "},{"type":"text","text":"“\/”, then we could write this as:"}],"type":"paragraph"},{"code":["OneOf {","  Parser { Int.parser(); \"-\"; Int.parser() } \/\/ 1️⃣","  Parser { Int.parser(); \"\/\"; Int.parser() } \/\/ 2️⃣","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"However, parsing slash-separated integers is not going to be performant because it will first","type":"text"},{"text":" ","type":"text"},{"text":"run the entire 1️⃣ parser until it fails, then backtrack to the beginning, and run the 2️⃣ parser.","type":"text"},{"text":" ","type":"text"},{"text":"In particular, the first integer will get parsed twice, unnecessarily repeating that work.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"On the other hand, we can factor out the common work of the parser and localize the backtracking","type":"text"},{"text":" ","type":"text"},{"code":"OneOf","type":"codeVoice"},{"text":" work to make a much more performant parser:","type":"text"}],"type":"paragraph"},{"code":["Parse {","  Int.parser()","  OneOf { \"-\"; \"\/\" }","  Int.parser()","}"],"type":"codeListing","syntax":"swift"}],"kind":"content"}],"topicSections":[{"title":"Initializers","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/init(_:)"]},{"title":"Instance Properties","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parsers"]},{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parse(_:)"]},{"generated":true,"title":"Default Implementations","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/Parser-Implementations"]}],"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"]]},"relationshipsSections":[{"kind":"relationships","type":"conformsTo","title":"Conforms To","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"]}],"references":{"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/replaceError(with:)":{"title":"replaceError(with:)","type":"topic","url":"\/documentation\/parsing\/oneof\/replaceerror(with:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"replaceError","kind":"identifier"},{"text":"(","kind":"text"},{"text":"with","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Output","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier","preciseIdentifier":"s:7Parsing7ParsersO"},{"text":".","kind":"text"},{"text":"ReplaceError","kind":"typeIdentifier","preciseIdentifier":"s:7Parsing7ParsersO12ReplaceErrorV"},{"text":"<","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":">","kind":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/replaceError(with:)","abstract":[{"text":"A parser that replaces its error with a provided output.","type":"text"}],"role":"symbol","kind":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing":{"abstract":[],"kind":"symbol","type":"topic","title":"Parsing","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","role":"collection","url":"\/documentation\/parsing"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/parsers":{"role":"symbol","abstract":[],"kind":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parsers","fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"text":"parsers","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier"}],"type":"topic","title":"parsers","url":"\/documentation\/parsing\/oneof\/parsers"},"doc://co.pointfree.Parsing/documentation/Parsing/Always":{"title":"Always","role":"symbol","kind":"symbol","url":"\/documentation\/parsing\/always","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Always","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Always"}],"navigatorTitle":[{"kind":"identifier","text":"Always"}],"type":"topic","abstract":[{"text":"A parser that always succeeds with the given value, and does not consume any input.","type":"text"}]},"doc://co.pointfree.Parsing/documentation/Parsing/OneOfBuilder":{"abstract":[{"type":"text","text":"A custom parameter attribute that constructs a parser that attempts to run a number of parsers,"},{"type":"text","text":" "},{"type":"text","text":"one after the other, till one succeeds with an output."}],"title":"OneOfBuilder","url":"\/documentation\/parsing\/oneofbuilder","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOfBuilder","role":"symbol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"OneOfBuilder"}],"fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"OneOfBuilder"}]},"doc://co.pointfree.Parsing/documentation/Parsing/Parser":{"type":"topic","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","title":"Parser","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"Parser","kind":"identifier"}],"abstract":[{"text":"Declares a type that can parse an ","type":"text"},{"type":"codeVoice","code":"Input"},{"text":" value into an ","type":"text"},{"type":"codeVoice","code":"Output"},{"text":" value.","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parser","kind":"identifier"}],"url":"\/documentation\/parsing\/parser"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf":{"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","title":"OneOf","url":"\/documentation\/parsing\/oneof","abstract":[{"text":"A parser that attempts to run a number of parsers till one succeeds.","type":"text"}],"navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"type":"topic","role":"symbol","kind":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/Parser-Implementations":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/Parser-Implementations","title":"Parser Implementations","url":"\/documentation\/parsing\/oneof\/parser-implementations","abstract":[],"type":"topic","role":"collectionGroup","kind":"article"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/parse(_:)":{"role":"symbol","abstract":[{"type":"text","text":"Attempts to parse a nebulous piece of data into something more well-structured."}],"kind":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/parse(_:)","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"parse","kind":"identifier"},{"text":"(","kind":"text"},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"rethrows","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"Parsers","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Output","kind":"typeIdentifier"}],"type":"topic","title":"parse(_:)","url":"\/documentation\/parsing\/oneof\/parse(_:)"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf/init(_:)":{"role":"symbol","abstract":[],"kind":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf\/init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"(() -> "},{"text":"Parsers","kind":"typeIdentifier"},{"text":")","kind":"text"}],"type":"topic","title":"init(_:)","url":"\/documentation\/parsing\/oneof\/init(_:)"}}}